<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Utils</name></assembly>
<members>
<member name="M:Swensen.Utils.List.equalsWith``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
Test whether the two lists are pairwise equal using the given boolean comparison function
</summary>
</member>
<member name="T:Swensen.Utils.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Swensen.Utils.Prelude">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Swensen.Utils.Printf.nprintfBuilder``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit},System.Boolean)">
<summary>
Normalize newlines to stdout.NewLine: if stdout.NewLine = &quot;\n&quot;, then do nothing.
Otherwise replace all occurences of &quot;\n&quot;, but not &quot;\r\n&quot;, with &quot;\r\n&quot; and then replace
all occurences of &quot;\r\n&quot; with stdout.NewLine.
</summary>
</member>
<member name="M:Swensen.Utils.Printf.nsprintf``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
Normalize newlines to Environment.NewLine: if Environment.NewLine = &quot;\n&quot;, then do nothing.
If Environment.NewLine = &quot;\r\n&quot;, then replace all occurences of &quot;\n&quot;, but not &quot;\r\n&quot;, with &quot;\r\n&quot;.
This allows &quot;\n&quot; to be used as an environment safe newline character, which may be mixed 
with uses of Environment.NewLine.
</summary>
</member>
<member name="P:Swensen.Utils.Printf.lfButNotCrLf">
<summary>
Matches &quot;\n&quot;, but not &quot;\r\n&quot;
</summary>
</member>
<member name="">

</member>
<member name="T:Swensen.Utils.Printf">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Swensen.Utils.Regex.|Match|_|(System.Text.RegularExpressions.RegexOptions,System.String,System.String)">
<summary>
Test an input string against a regex pattern using the given RegexOptions flags. 
If the match succeeds, returns an ActiveMatch instance, which can be used for further pattern matching.
Note that the implementation takes advantage of the .NET Regex cache.
</summary>
<param name="flags">
The first argument allows you pass in RegexOptions flags. 
</param>
<param name="pattern">
The second argument is the regex pattern. Cannot be null. 
</param>
<param name="input">
The last argument is the input string to test. The input
may be null which would result in a no-match.
</param>
</member>
<member name="">

</member>
<member name="T:Swensen.Utils.Regex.Interpreted">
<summary>
Convenience versions of our regex active patterns using RegexOptions.None flag
</summary>
</member>
<member name="">

</member>
<member name="P:Swensen.Utils.Regex.Compiled.compiledRegexOption">
<summary>
When silverlight mode is None, else is Compiled
</summary>
</member>
<member name="T:Swensen.Utils.Regex.Compiled">
<summary>
Convenience versions of our regex active patterns using RegexOptions.Compiled flag.
If SILVERLIGHT compiler directive defined, then RegexOptions.None flag used.
</summary>
</member>
<member name="T:Swensen.Utils.Regex">
<summary>
Regex extensions
</summary>
</member>
</members>
</doc>
