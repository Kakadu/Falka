Неформальная инструкция по-русски.

В рамках проекта были реализованы парсер-комбинаторы (директория FalkaCommon).
Их следует использовать для написания своих парсеров (примеры в директории Test).
Скомпилировав парсер в DLL его можно дать Falka.exe, которая проанализирует код,
и, возможно, сгенерирует код гибридного парсера, сочетающего комбинаторы и FsYacc.

Проекты для тестирования гибридного парсера --- это HybridTest1 и HybridTest2. Туда Falka
складывает генеренный код. В первом проекте также есть код для тестирования производительности 
этих двух парсеров, и FParsec-парсера из Test/Test2FParsec.fs.

Ради моего удобства тестирования я захардкодил некоторые параметры в начале Falka/Program.fs.
Передавать их как парметры командной строки в Windows, ИМХО, неудобно.

Порядок компиляции такой:
 * меняем код парсера в проекте Test
 * запускаем Falka, чтобы она генерировала новый код
 * запускаем HybridTest1 или 2 (смотря куда Фалька складывала файлы), чтобы протестировать то, 
   что получилось.

I. Как стоит писать свой парсер?
В этот парсер будет передаваться поток токенов, завернутый в тип ITokenLexer. Само получение токенов
можно делать по-разному (с помощью FParsec или FsLex). Cреди токенов должен быть EOF без параметров.
Далее мы должны написать свой парсер. Методами класса будут парсер-функции. Вот пример из Test/Test2.fs
Для того, чтобы анализатор смог хорошо проанализировать тело, будет писать содержательную часть 
внутри let body = ....

  abstract member Expression: ITokenLexer<token> -> Result<ast,token>
  [<ParserFunction>]
  default this.Expression stream =
    let body = 
        (pipe3 this.Number this.Operator this.Expression (fun a op c -> AExpr (op, ANumber a,c)))
        <|> (this.Number |>> (fun x -> ANumber x) )
    wrap_meth stream body
  
  abstract member Start: ITokenLexer<token> -> Result<ast,token>
  default this.Start stream =
    let body = this.Expression .>> this.EOF
    wrap_meth stream body

Это код "эквивалентен" грамматике
Start ::= Expression EOF
Expression ::= Number Operator Expression | Number

this.Start и this.Expression --- содержательные парсер-функции. Остальные --- для получения токенов 
из потока (см. пример)

Теперь про атрибуты. Чтобы можно было анализировать код функций у парсер-фунций должен стоять
атрибут ParserFunction. Методы без атрибута рискуют не появиться в гибридной грамматике.
Методы виртуальные, так как для получения нового парсера применяется наследование.

У класса тоже стоит атрибут <ParserClassAttribute("какое правило перегонять в LALR", 
"в каком модуле описан тип token","какие модули пооткрывать в нагенеренном классе.")

Далее, надо скомпилировать класс и передать его анализатору Falka.exe
------------------------------------
II. кодогенератор
Falka.exe -h показывает передаваемые опции: DLLка, namespace парсера, имя класса парсера и 
куда складывать генеренный код.
Также есть опция для переопределения дефолного положения FsYacc
В указанной директории должно появиться несколько файлов.
gr.yrd --- сгенеренная в ярд грамматика.
HybridParser.fs[yi] --- LALR анализатор грамматики
HybridCaller.fs --- здесь происходит наследование и создание нового парсера. 
                Парсер отсюда надо будет вызывать.

III. Тестирование гибридного парсера
Протестировать из коробки можно два примера. Для них есть дефотные настройки в начале файла
Falka/Programs.fs (если не хочется вызывать вручную из ком.строки).
1) Ну очень простая арифметика в файле Test/Test2.fs. Выход складывается в проект HybridTest1.
2) А ля SQL. Гибридный парсер в проекте HybridTest2



